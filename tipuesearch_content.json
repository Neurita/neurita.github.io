{"pages":[{"url":"https://neurita.github.io/how_to_interact_with_mitk_images_from_python","title":"How to interact with MITK images from Python","tags":"MITK, python","text":"Extending your MITK plugin I recommend that you build MITK with Boost enabled, also adding filesystem to the variable MITK_USE_Boost_LIBRARIES . It is not strictly necessary, but recommended for this example. Following the previous recommendation, you will need to modify your plugin CMakeLists.txt . project ( com_company_example_python ) mitk_create_plugin ( EXPORT_DIRECTIVE EXAMPLE_PYTHON_EXPORT EXPORTED_INCLUDE_SUFFIXES src MODULE_DEPENDS MitkQtWidgetsExt MitkPython PACKAGE_DEPENDS Boost #Add this line ) Boost in your plugin view file MyView.cpp . // Boost #include <boost/filesystem.hpp> namespace fs = boost :: filesystem ; using fs :: path ; In order to follow this tutorial you will probably need the plugin source code. You can found it in my repository @ljsalvatierra. LJSView.cpp Python module Method 1: SimpleITK Process a SimpleItk image and load it in the MITK Viewer. //DoImageProcessing() mitk :: Image :: Pointer postProcessedImage = this -> ProcessSimpleItkImageInPython ( image ); this -> LoadImage ( node , postProcessedImage , name ); Where node is a mitk::DataNode that contains the image. And name is one of the properties of the node . I have successfully tested the plugin with Raw .nrrd and Dicom .dcm images. The Dicom images must be loaded with the Open Dicom tool , once that is loaded in the DataStorage you can get the image from the node . How do we send the image to our Python module? Import the module. StringList code = QStringList () << \"import sys\" << \"try:\" << \" sys.path.append('\" + pythonScriptsPath + \"')\" << \" import \" + pythonPluginName + \" as \" + pythonPluginNameAlias << \" plugin_available = True\" << \"except ImportError:\" << \" plugin_available = False\" << \" raise ImportError('No module named \" + pythonPluginName + \"')\" If we successfully import the module, call an example function. << \"if plugin_available:\" << \" try:\" << \" \" + pythonOutputImage + \" = \" + pythonPluginNameAlias + \".\" + pythonPluginFunction + \"(\" + pythonInputImage + \")\" << \" except TypeError:\" << \" raise TypeError('Image Type Error')\" ; Run the script. const std :: string command = code . join ( \" \\n \" ). toStdString (); m_PythonService -> Execute ( command , mitk :: PythonService :: MULTI_LINE_COMMAND ); Ok, but where is pythonOutputImage ? Thanks to PythonService we can get all the variables saved in the stack. std :: vector < mitk :: PythonVariable > list = m_PythonService -> GetVariableStack (); mitk :: Image :: Pointer outputImage ; if ( m_PythonService -> DoesVariableExist ( pythonOutputImage . toStdString ()) ) { outputImage = m_PythonService -> CopySimpleItkImageFromPython ( pythonOutputImage . toStdString ()); } Now that we have the image, how do we load it in the Workbench Viewer? Create a new node and populate it. mitk :: DataNode :: Pointer ds = mitk :: DataNode :: New (); ds -> SetData ( image ); ds -> SetProperty ( \"name\" , mitk :: StringProperty :: New ( name + \"_postProcessedImage\" )); Add the new node to the DataStorage with the original image as Parent node . this -> GetDataStorage () -> Add ( ds , originalImageNode ); Update the RenderingManager . mitk :: RenderingManager :: GetInstance () -> RequestUpdateAll (); And that's it, you should see the processed image like this. Method 2: Other (process an image from path) This example doesn't work for dicom images. Process an image from path. std :: string imagePath = this -> GetDataPath ( data ); path p = path ( imagePath ); std :: string filename = p . filename (). string (); std :: string postProcessedImagePath = \"/tmp/postProcessed_\" + filename ; this -> ProcessImageInPython ( imagePath , postProcessedImagePath ); this -> LoadImageFromPath ( node , postProcessedImagePath , filename ); Where GetDataPath() is a function to get the image path inside mitk::BaseData . std :: string imagePath = ( data -> GetProperty ( \"path\" )) -> GetValueAsString (); How do we send the image path to our Python module? Import the module, as in the first method (SimpleITK). QStringList code = QStringList () << \"import sys\" << \"try:\" << \" sys.path.append('\" + pythonScriptsPath + \"')\" << \" import \" + pythonPluginName + \" as \" + pythonPluginNameAlias << \" plugin_available = True\" << \"except ImportError:\" << \" plugin_available = False\" << \" raise ImportError('No module named \" + pythonPluginName + \"')\" If we successfully import the module, call and example function. << \"if plugin_available:\" << \" try:\" << \" \" + pythonPluginNameAlias + \".\" + pythonPluginFunction + \"('\" + pythonInputImage + \"','\" + pythonOutputImage + \"')\" << \" except TypeError:\" << \" raise TypeError('Image Type Error')\" ; Run the script. const std :: string command = code . join ( \" \\n \" ). toStdString (); m_PythonService -> Execute ( command , mitk :: PythonService :: MULTI_LINE_COMMAND ); Now we need to get the output image path. Get the path from the variable stack. std :: string outputImage ; std :: vector < mitk :: PythonVariable > list = m_PythonService -> GetVariableStack (); for ( auto & i : list ){ if ( i . m_Name == pythonOutputImage . toStdString () ) { outputImage = i . m_Value ; break ; } } Load the image in the Workbench Viewer. Create a new node and load the image from path. mitk :: StandaloneDataStorage :: Pointer ds = mitk :: StandaloneDataStorage :: New (); mitk :: StandaloneDataStorage :: SetOfObjects :: Pointer dataNodes = mitk :: IOUtil :: Load ( processedImage , * ds ); mitk :: DataNode :: Pointer node = dataNodes -> at ( 0 ); Add the new node to the DataStorage with the original image as Parent node . this -> GetDataStorage () -> Add ( node , originalImageNode ); Update the RenderingManager . mitk :: RenderingManager :: GetInstance () -> RequestUpdateAll (); The result, as before, should look like this."},{"url":"https://neurita.github.io/how_to_create_a_python_plugin_for_mitk","title":"How to create a Python plugin for MITK","tags":"MITK, python","text":"Plugins examples MITK plugins . MITK projects . Creating a MITK plugin For more information, go to MitkPluginGenerator . There are two ways of accomplish the same result.: Creating a MITK plugin .: $ ./MitkPluginGenerator --plugin-symbolic-name org.mycompany.myplugin --view-name \"My View\" Creating a MITK project (recommended).: $ ./MitkPluginGenerator --plugin-symbolic-name org.mycompany.myplugin --view-name \"My View\" \\ --project-name \"MyProject\" --project-app-name \"MyApp\" It is recommended to take the second approach because you only have to build MITK once. With the first approach you would have to rebuild MITK every time you make a change to your plugin/s, instead, with the second approach, each time you make a change to your plugin, you only have to compile your project. Creating a MITK plugin $ /path/to/MITK-build/bin/MitkPluginGenerator -h $ /path/to/MITK-build/bin/MitkPluginGenerator --out-dir /output/directory \\ --vendor Plugin_vendor_name --view-name \"My View\" --plugin-symbolic-name org.mycompany.myplugin $ cd /output/directory && ls org.mycompany.myplugin $ cd org.mycompany.myplugin && ls CMakeLists.txt documentation files.cmake manifest_headers.cmake plugin.xml resources src Modify MITK to build with the new plugin.: $ cp -r ../org.mycompany.myplugin /path/to/MITK/Plugins && cd /path/to/MITK/Plugins $ vim PluginList.cmake # Add your plugin with the flag 'ON'. set ( MITK_PLUGINS org.mycompany.myplugin:ON org.blueberry.core.runtime:ON ... Set a new CTK Plugin in CMakeLists.txt .: $ cd /path/to/MITK $ vim CMakeLists.txt # Search the string 'set(re_ctkplugin' /set ( re_ctkplugin Modify it to look like this.: # Specify which plug-ins belong to this project macro ( GetMyTargetLibraries all_target_libraries varname ) set ( re_ctkplugin_mitk \"&#94;org_mitk_[a-zA-Z0-9_]+$\" ) set ( re_ctkplugin_bb \"&#94;org_blueberry_[a-zA-Z0-9_]+$\" ) set ( re_ctkplugin_mycompany \"&#94;org_mycompany_[a-zA-Z0-9_]+$\" ) set ( _tmp_list ) list ( APPEND _tmp_list ${ all_target_libraries } ) ctkMacroListFilter ( _tmp_list re_ctkplugin_mitk re_ctkplugin_bb re_ctkplugin_mycompany OUTPUT_VARIABLE ${ varname } ) endmacro () `set(re_ctkplugin_`**`mycompany \"&#94;org_mycompany_[a-zA-Z0-9_]+$\"`**`)` `ctkMacroListFilter(_tmp_list re_ctkplugin_mitk re_ctkplugin_bb `**`re_ctkplugin_mycompany`**` OUTPUT_VARIABLE ${ varname } )` Modify your plugin Add Python module dependency to the plugin CMakeLists.txt . mitk_create_plugin ( EXPORT_DIRECTIVE EXAMPLE_EXPORT EXPORTED_INCLUDE_SUFFIXES src MODULE_DEPENDS MitkQtWidgetsExt MitkPython ) Embed Python in the new plugin Interact with Mitk Python Service . When we create a plugin with MitkPluginGenerator the default view contains a button Do something . Each time we press that button, it calls the function DoImageProcessing() that prints a message in the console/terminal. // MyView.cpp ... // Add the Python Service header #include <mitkPythonService.h> ... // If you followed the instructions then you have the default plugin // with this function void MyView :: DoImageProcessing () { QList < mitk :: DataNode :: Pointer > nodes = this -> GetDataManagerSelection (); if ( nodes . empty ()) return ; mitk :: DataNode * node = nodes . front (); if ( ! node ) { // Nothing selected. Inform the user and return QMessageBox :: information ( NULL , \"Template\" , \"Please load and select an image before starting image processing.\" ); return ; } ... Add this two line example to the end of the function DoImageProcessing() .: ... message << \".\" ; //MITK_INFO << message.str(); // Each time we press that button will print `Hello World!` in the console/terminal // First we interact with mitkPythonService and execute a simple Python function. itk :: SmartPointer < mitk :: PythonService > _PythonService ( new mitk :: PythonService ()); std :: string result = _PythonService -> Execute ( \"print ('Hello World!')\" , mitk :: IPythonService :: SINGLE_LINE_COMMAND ); message << \" \\n \" ; message << result << \" \\n \" ; MITK_INFO << message . str (); ... Build MITK with your new plugin $ cd /path/to/MITK-build #Clean directory $ ccmake ../MITK # Build with the option MITK_USE_PYTHON enabled. # Configure and enable the option MITK_USE_SYSTEM_PYTHON # Configure and toggle the advance view. # Modify the Python path, library path and debug path, to use Python2.7 instead of Python3.4 or Python3.4m. # Configure again and generate. $ make # The last command will take several hours. Creating a MITK project $ mkdir MITK-projects && cd MITK-projects $ /path/to/MitkPluginGenerator -h $ /path/to/MitkPluginGenerator --plugin-symbolic-name org.mycompany.myplugin \\ --view-name \"My View\" --project-name \"MyProject\" --project-app-name \"MyApp\" $ cd MyProject && ls Apps build CMake CMakeExternals CMakeLists.txt LICENSE.txt Plugins SuperBuild.cmake Modify your project/plugin $ cd Plugins/org.mycompany.myplugin/src/internal && ls org_mycompany_myplugin_Activator.cpp org_mycompany_myplugin_Activator.h MyViewControls.ui MyView.cpp MyView.h $ vim MyView.cpp Embed Python in the new plugin . This part is shared between the two approaches. Add Python module dependency to the plugin CMakeLists.txt . $ vim /path/to/MyProject/Plugins/org.mycompany.myplugin/CMakeLists.txt project ( org_mycompany_myplugin ) mitk_create_plugin ( EXPORT_DIRECTIVE MYPLUGIN_EXPORT EXPORTED_INCLUDE_SUFFIXES src MODULE_DEPENDS MitkQtWidgetsExt MitkPython ) Build your new project $ cd /path/to/MyProject $ mkdir build && cd build $ ccmake .. Press 't' to toggle advanced mode and specify the EXTERNAL_MITK_DIR Configure and look if there are any modules left For example.: MITK_BUILD_ALL_PLUGINS ON MITK_VTK_DIR /path/to/ MITK -build/ep/share/vtk-6.2 MITK_OpenCV_DIR /path/to/ MITK -build/ep/src/OpenCV-build … Test it! Open the MitkWorkbench : $ /path/to/MITK-build/bin/MitkWorkbench Or open your Project Launcher: $ /path/to/MyProject/build/MyProject-build/bin/MyApp Open your plugin view: Open a new image to be able to press the button Do something : You should see this when pressing the button Do something :"},{"url":"https://neurita.github.io/how_to_compile_mitk_on_docker","title":"How to compile MITK on Docker","tags":"MITK, build","text":"Required packages Docker GIT CMake (version 3.2 or higher. Current stable 3.3) Qt 5.x Note: Make sure that you select a Qt version which provides the right OpenGL-enabled packages for your architecture and compiler. Install dependencies Install Docker $ sudo apt-get update $ sudo apt-get install curl $ curl -sSL https://get.docker.com/ | sh Option 1: Ubuntu 14.04 Pull a Docker container with Ubuntu:14.04 and run it: $ docker pull ubuntu:14.04 $ docker images $ docker run -i -t <IMAGE_ID> /bin/bash Once inside the Ubuntu 14.04 container, install MITK dependencies: root@XXXXX:$ apt-get update && apt-get install -y \\ software-properties-common \\ && apt-add-repository multiverse \\ && apt-get update \\ && apt-get install -y \\ bison build-essential curl git libarchive-dev libbz2-ocaml-dev libcurl4-openssl-dev \\ libexpat-ocaml-dev libfaac-dev libmp3lame-dev libopencore-amrnb-dev libopencore-amrwb-dev \\ libqt5svg5-dev libqt5webkit5-dev libqt5xmlpatterns5-dev libtheora-dev libtiff5-dev \\ libvorbis-dev libvpx-dev libwrap0-dev libxi-dev libxmu-dev pkg-config qt5-default \\ qtscript5-dev qttools5-dev qttools5-dev-tools vim wget yasm libgtk2.0-dev Option 2: Ubuntu 15.04 Pull a Docker container with Ubuntu 15.04 and run it: $ docker pull ubuntu:15.04 $ docker images $ docker run -i -t <IMAGE_ID> /bin/bash Once inside the container: root@XXXXX:$ apt-get update && apt-get install -y \\ software-properties-common \\ && apt-add-repository multiverse \\ && apt-get update \\ && apt-get install -y \\ bison build-essential curl git libarchive-dev libbz2-ocaml-dev libcurl4-openssl-dev \\ libexpat1-dev libfaac-dev libmp3lame-dev libopencore-amrnb-dev libopencore-amrwb-dev \\ libqt5svg5-dev libqt5webkit5-dev libqt5xmlpatterns5-dev libtheora-dev libtiff5-dev \\ libvorbis-dev libvpx-dev libwrap0-dev libxi-dev libxmu-dev python-dev pkg-config \\ qt5-default qtscript5-dev qttools5-dev qttools5-dev-tools vim wget yasm libgtk2.0-dev Install MITK in the container Now on follow the installation instructions in this post . Build MITK root@XXXXX:$ git clone http://git.mitk.org/MITK.git root@XXXXX:$ mkdir MITK-build && cd MITK-build root@XXXXX:$ ccmake ../MITK Note: in Ubuntu:14.04 you CAN 'T select the option ‘MITK_USE_Python', because It needs Qt >= 5.3 Tips: For a complete installation, press ‘t' to toggle the advance view. You may select all the options you desire, like compile with all applications and plugins. Also, if you selected MITK_USE_SYSTEM_PYTHON , you may want to change PYTHON_EXECUTABLE , PYTHON_INCLUDE_DIR and PYTHON_LIBRARY to your respective installation. For now, It's not possible to use Python 3, so you'll have to use Python2.7. # Press 'c' to configure and 'g' to generate and exit. root@XXXXX:$ make # I do NOT recommend running `make` with the option `-j4`. You'll get dependency related errors during the build. # This last command will take several hours, so go and take a walk (in another city) :) root@XXXXX:$ exit $ docker ps -l CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES b378149da6c6 ubuntu:15.04 \"/bin/bash\" 8 hours ago Exited ( 0 ) 10 seconds ago focused_newton $ docker commit <CONTAINER_NAME> ubuntu15/mitk:latest # See the CONTAINER_NAME on the right of `docker ps -l` Running MITK Create a Dockerfile .: FROM <IMAGE> MAINTAINER <YOUR_NAME> ENV MITK_WORKBENCH /path/to/MITK-build/bin/MitkWorkbench CMD $MITK_WORKBENCH Where <IMAGE> is the name of the image where we have installed MITK . e.g.: FROM ubuntu15/mitk:latest $ docker images REPOSITORY TAG IMAGE ID CREATED VIRTUAL SIZE ubuntu15/mitk latest 19af721ab6a3 11 hours ago 13.2 GB Build a new image with the Dockerfile.: $ docker build --rm -t mitk:15.04 . $ docker images REPOSITORY TAG IMAGE ID CREATED VIRTUAL SIZE mitk 15.04 bdcce6cafa44 26 minutes ago 13.2 GB $ docker ps -l CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 2f140ab82356 mitk:15.04 \"/bin/bash\" 42 minutes ago Exited ( 0 ) 41 minutes ago silly_galileo $ xhost +local: ` docker inspect --format = '{{ .Config.Hostname }}' <CONTAINER_ID> ` $ docker run -ti --rm -e DISPLAY = $DISPLAY -v /tmp/.X11-unix:/tmp/.X11-unix mitk:15.04"},{"url":"https://neurita.github.io/how_to_compile_mitk_on_ubuntu","title":"How to compile MITK on Ubuntu","tags":"MITK, build","text":"Required packages GIT CMake (version 3.2 or higher. Current stable 3.3) Qt 5.x Note: Make sure that you select a Qt version which provides the right OpenGL-enabled packages for your architecture and compiler. Install dependencies Option 1: Ubuntu 14.04 $ sudo apt-get update && sudo apt-get install -y \\ software-properties-common \\ && sudo apt-add-repository multiverse \\ && sudo apt-get update \\ && sudo apt-get install -y \\ bison build-essential curl git libarchive-dev libbz2-ocaml-dev libcurl4-openssl-dev \\ libexpat-ocaml-dev libfaac-dev libmp3lame-dev libopencore-amrnb-dev libopencore-amrwb-dev \\ libqt5svg5-dev libqt5webkit5-dev libqt5xmlpatterns5-dev libtheora-dev libtiff5-dev \\ libvorbis-dev libvpx-dev libwrap0-dev libxi-dev libxmu-dev pkg-config qt5-default \\ qtscript5-dev qttools5-dev qttools5-dev-tools vim wget yasm libgtk2.0-dev Option 2: Ubuntu 15.04 $ sudo apt-get update && sudo apt-get install -y \\ software-properties-common \\ && sudo apt-add-repository multiverse \\ && sudo apt-get update \\ && sudo apt-get install -y \\ bison build-essential curl git libarchive-dev libbz2-ocaml-dev libcurl4-openssl-dev \\ libexpat1-dev libfaac-dev libmp3lame-dev libopencore-amrnb-dev libopencore-amrwb-dev \\ libqt5svg5-dev libqt5webkit5-dev libqt5xmlpatterns5-dev libtheora-dev libtiff5-dev \\ libvorbis-dev libvpx-dev libwrap0-dev libxi-dev libxmu-dev python-dev pkg-config \\ qt5-default qtscript5-dev qttools5-dev qttools5-dev-tools vim wget yasm libgtk2.0-dev Other dependencies Install OpenCL # OpenCL for Intel/AMD: $ sudo apt-get install ocl-icd-opencl-dev # OpenCL for Nvidia: $ sudo apt-get install nvidia-opencl-icd-XXX # Where XXX is the version. Current 346 Build Cmake 3.3.0 $ wget -c http://www.cmake.org/files/v3.3/cmake-3.3.0.tar.gz $ tar xvzf cmake-3.3.0.tar.gz && cd cmake-3.3.0 $ ./bootstrap --prefix = /usr --system-libs --mandir = /share/man --no-system-jsoncpp \\ --docdir = /share/doc/cmake-3.3.0 --qt-gui $ make && sudo make install Build FFmpeg FFmpeg is required for OpenCV. $ git clone https://github.com/FFmpeg/FFmpeg.git $ cd FFmpeg $ ./configure --enable-gpl --enable-libfaac --enable-libmp3lame --enable-libopencore-amrnb \\ --enable-libopencore-amrwb --enable-libtheora --enable-libvorbis --enable-libvpx \\ --enable-nonfree --enable-version3 --enable-x11grab --enable-shared --enable-pic $ make && sudo make install Build MITK $ git clone http://git.mitk.org/MITK.git $ mkdir MITK-build && cd MITK-build $ ccmake ../MITK Note: in Ubuntu:14.04 you CAN 'T select the option ‘MITK_USE_Python', because It needs Qt >= 5.3 Tips: For a complete installation, press ‘t' to toggle the advance view. You may select all the options you desire, like compile with all applications and plugins. Also, if you selected MITK_USE_SYSTEM_PYTHON , you may want to change PYTHON_EXECUTABLE , PYTHON_INCLUDE_DIR and PYTHON_LIBRARY to your respective installation. For now, It's not possible to use Python 3, so you'll have to use Python2.7. # Press 'c' to configure and 'g' to generate and exit. $ make # I do NOT recommend running `make` with the option `-j4`. You'll get dependency related errors during the build. # This last command will take several hours, so go and take a walk (in another city) :) If you encounter any problems building MITK , try building your self some of Its dependencies.: Build Boost if needed Download Boost from the official webpage Boost C++ Libraries . $ tar --bzip2 -xf /path/to/boost_1_XX_X.tar.bz2 && cd boost_1_XX_X #Current `boost_1_58_0` $ ./bootstrap.sh --prefix = /usr/local --with-python = /usr/bin/python2 #It doesn't work with Python3 $ mkdir ../boost-build $ sudo ./b2 -q --build-dir = ../boost-build variant = release install Build OpenCV if needed $ sudo apt-get install build-essential libgtk2.0-dev pkg-config libavcodec-dev libavformat-dev \\ libswscale-dev python-dev python-numpy libtbb2 libtbb-dev libjpeg-dev libpng-dev libtiff-dev \\ libjasper-dev libdc1394-22-dev $ git clone git@github.com:Itseez/opencv.git $ mkdir opencv-build && cd opencv-build $ ccmake ../opencv # Press 'c' to configure and 'g' to generate and exit. $ make -j4 # Where *4 is the number of CPU Threads. # The last command will take several minutes to complete. $ sudo make install Build VTK if needed $ sudo apt-get install tk-dev $ git clone git://vtk.org/VTK.git $ mkdir VTK-build && cd VTK-build $ ccmake ../VTK # Press 'c' to configure and 'e' to continue. # Select desired options. # VTK_WRAP_PYTHON ON # VTK_QT_VERSION 5 # ... # Press again 'c' to configure and 'e' to continue. # Press 'g' to generate and exit. $ make -j4 $ sudo make install Build SOFA if needed $ git clone git://scm.gforge.inria.fr/sofa/sofa.git $ sudo apt-get install build-essential libqt4-dev libqt4-opengl-dev libglew-dev freeglut3-dev \\ libpng-dev ccache zlib1g-dev python2.7-dev libxml2-dev libcgal-dev libblas-dev liblapack-dev \\ libsuitesparse-dev libboost-all-dev libassimp-dev liboce-foundation-dev $ mkdir sofa-build && cd sofa-build $ CC = \"gcc\" CXX = \"g++\" cmake -DCMAKE_BUILD_TYPE = Release ../sofa $ cmake . $ make -j4 Build GDCM if needed $ sudo apt-get install swig $ git clone --branch release git://git.code.sf.net/p/gdcm/gdcm $ mdkir gdcm-build && cd gdcm-build $ ccmake ../gdcm # Press 'c' to configure and 'g' to generate and exit. $ make $ sudo make install Run MITK $ cd ~/Downloads && wget -c http://mitk.org/download/tutorial-data/Pic3D.nrrd $ /path/to/MITK-build/bin/MitkWorkbench Open the downloaded image in ~/Downloads"}]}